<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>UMAP Interactive Explainer</title>
  <style>
    :root {
      --bg: #020817;
      --bg-soft: #030b21;
      --accent: #22c55e;
      --accent-soft: rgba(34, 197, 94, 0.2);
      --accent2: #38bdf8;
      --accent2-soft: rgba(56, 189, 248, 0.18);
      --muted: #9ca3af;
      --border: #111827;
      --font: system-ui, -apple-system, BlinkMacSystemFont, -sans-serif;
      --radius-xl: 18px;
      --shadow-soft: 0 18px 55px rgba(15,23,42,0.8);
      --transition-fast: 0.18s ease-out;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 24px;
      font-family: var(--font);
      background: radial-gradient(circle at top, #020817 0, #000 55%);
      color: #e5e7eb;
    }

    h1, h2, h3 {
      margin: 0;
      font-weight: 600;
      letter-spacing: 0.02em;
    }

    a {
      color: var(--accent2);
      text-decoration: none;
    }

    .app-root {
      max-width: 1320px;
      margin: 0 auto;
      display: grid;
      grid-template-rows: auto auto 1fr;
      gap: 16px;
    }

    .hero {
      padding: 18px 22px 16px;
      border-radius: var(--radius-xl);
      background: radial-gradient(circle at top left, rgba(34,197,94,0.11), transparent),
                  radial-gradient(circle at top right, rgba(56,189,248,0.06), transparent),
                  rgba(2,6,23,0.98);
      border: 1px solid rgba(148,163,253,0.06);
      box-shadow: var(--shadow-soft);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 16px;
    }

    .hero-left {
      max-width: 760px;
    }

    .hero-title {
      font-size: 26px;
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border-radius: 999px;
      font-size: 10px;
      color: var(--accent);
      border: 1px solid rgba(34,197,94,0.25);
      background: radial-gradient(circle at top, rgba(34,197,94,0.22), transparent);
    }

    .hero-sub {
      font-size: 13px;
      color: var(--muted);
    }

    .hero-right {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
      font-size: 10px;
      color: var(--muted);
    }

    .hero-badge {
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,253,0.14);
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: rgba(9,9,22,0.96);
    }

    .layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 14px;
      align-items: stretch;
    }

    @media (max-width: 960px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: radial-gradient(circle at top, rgba(15,23,42,0.7), transparent),
                  rgba(2,6,23,0.98);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border);
      padding: 12px 12px 10px;
      box-shadow: 0 18px 50px rgba(0,0,0,0.85);
    }

    .panel h2 {
      font-size: 13px;
      margin-bottom: 4px;
      color: #e5e7eb;
    }

    .label {
      font-size: 10px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .controls-group {
      margin-bottom: 10px;
    }

    select, input[type="number"], input[type="range"] {
      width: 100%;
      background: #020817;
      color: #e5e7eb;
      border-radius: 10px;
      border: 1px solid rgba(75,85,99,0.8);
      padding: 5px 7px;
      font-size: 10px;
      outline: none;
      transition: border var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast);
    }

    select:focus, input[type="number"]:focus, input[type="range"]:focus {
      border-color: var(--accent2);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.2);
      background: #020817;
    }

    input[type="range"] {
      padding: 0;
      height: 16px;
      cursor: pointer;
    }

    .step-labels {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      margin-top: 2px;
      font-size: 8px;
      color: var(--muted);
    }

    .step-labels span {
      text-align: center;
      padding: 2px 3px;
      border-radius: 999px;
      border: 1px solid transparent;
    }

    .step-labels span.active {
      color: var(--accent2);
      border-color: rgba(56,189,248,0.5);
      background: radial-gradient(circle at top, var(--accent2-soft), transparent);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      padding: 5px 9px;
      border-radius: 999px;
      border: 1px solid rgba(75,85,99,0.9);
      font-size: 10px;
      background: #020817;
      color: #e5e7eb;
      cursor: pointer;
      transition: all var(--transition-fast);
      margin-right: 4px;
      margin-top: 2px;
    }

    .btn:hover {
      border-color: var(--accent2);
      box-shadow: 0 8px 20px rgba(15,23,42,0.8);
      transform: translateY(-1px);
      background: radial-gradient(circle at top, rgba(56,189,248,0.07), #020817);
    }

    .btn.primary {
      border-color: var(--accent);
      color: var(--accent);
    }

    .btn.small {
      padding: 3px 7px;
      font-size: 9px;
    }

    .math-block {
      font-family: "SF Mono", Menlo, Monaco, monospace;
      font-size: 9px;
      color: var(--accent2);
      background: #020817;
      padding: 5px 6px;
      border-radius: 8px;
      border: 1px solid rgba(56,189,248,0.18);
      margin: 3px 0;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    .explain-text {
      font-size: 10px;
      color: var(--muted);
      line-height: 1.55;
      margin-top: 4px;
      max-height: 260px;
      overflow-y: auto;
      padding-right: 2px;
    }

    .explain-highlight {
      color: var(--accent);
      font-weight: 500;
    }

    .visuals {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      height: 410px;
    }

    @media (max-width: 960px) {
      .visuals {
        grid-template-columns: 1fr;
        height: auto;
      }
    }

    .canvas-card {
      position: relative;
      border-radius: var(--radius-xl);
      padding: 7px;
      border: 1px solid var(--border);
      background:
        radial-gradient(circle at top, rgba(34,197,94,0.06), transparent),
        rgba(2,6,23,1);
      box-shadow: 0 16px 40px rgba(0,0,0,0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .canvas-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 9px;
      color: var(--muted);
    }

    .canvas-title strong {
      font-size: 10px;
      color: #e5e7eb;
      font-weight: 500;
    }

    canvas {
      flex: 1;
      border-radius: 12px;
      background: radial-gradient(circle at top, rgba(15,23,42,0.7), transparent),
                  #020817;
      border: 1px solid rgba(31,41,55,0.9);
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      font-size: 8px;
      color: var(--muted);
    }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 50%;
      display: inline-block;
      margin-right: 3px;
      background: var(--accent);
    }

    .dot2 {
      background: var(--accent2);
    }

    .status {
      font-size: 8px;
      color: var(--accent2);
      margin-left: 4px;
    }
  </style>
</head>
<body>
<div class="app-root">
  <section class="hero">
    <div class="hero-left">
      <div class="pill">
        <span>UMAP Visual Notebook</span>
        <span>step-by-step • interactive</span>
      </div>
      <div class="hero-title">
        <span>Understanding UMAP with Geometry, Graphs & Gradients</span>
      </div>
      <p class="hero-sub">
        UMAP (Uniform Manifold Approximation and Projection) builds a weighted graph of local neighborhoods in your
        original space, then finds a 2D embedding whose fuzzy graph looks the same.
        Use the controls to walk through each stage — data → neighbors → fuzzy graph → layout.
      </p>
    </div>
    <div class="hero-right">
      <div class="hero-badge">
        <span>⚙️</span><span>All in-browser · No backend</span>
      </div>
      <div>Try different datasets, neighbors, and watch the embedding optimize live.</div>
    </div>
  </section>

  <section class="layout">
    <!-- LEFT: Controls + Explanation -->
    <aside class="panel">
      <h2>1. Configure & Explore</h2>

      <div class="controls-group">
        <div class="label">Dataset (simulates high-dimensional structure)</div>
        <select id="datasetSelect">
          <option value="moons">Two Moons (nonlinear)</option>
          <option value="blobs">Separated Blobs</option>
          <option value="swiss">Swiss Roll (3D → 2D)</option>
        </select>
      </div>

      <div class="controls-group">
        <div class="label">Number of points</div>
        <input id="numPoints" type="number" min="40" max="800" value="250" />
      </div>

      <div class="controls-group">
        <div class="label">k — neighbors per point (local connectivity)</div>
        <input id="kNeighbors" type="range" min="3" max="40" value="12" />
        <div class="step-labels" id="kLabel">
          <!-- Populated by JS -->
        </div>
      </div>

      <div class="controls-group">
        <div class="label">Step through the algorithm</div>
        <input id="stepSlider" type="range" min="1" max="4" value="1" />
        <div class="step-labels">
          <span data-step-label="1" class="active">1 · Data</span>
          <span data-step-label="2">2 · kNN Graph</span>
          <span data-step-label="3">3 · Fuzzy Graph</span>
          <span data-step-label="4">4 · 2D Layout</span>
        </div>
      </div>

      <div class="controls-group">
        <button class="btn small" id="regenBtn">↻ Regenerate dataset</button>
        <button class="btn small primary" id="rebuildBtn">Build graph</button>
        <button class="btn small" id="resetLayoutBtn">Reset layout</button>
        <button class="btn small" id="playBtn">▶ Run layout</button>
        <div class="status" id="statusText"></div>
      </div>

      <div class="math-block" id="mathBlock">
        <!-- Filled by JS -->
      </div>

      <div class="explain-text" id="explainText">
        <!-- Filled by JS -->
      </div>
    </aside>

    <!-- RIGHT: Visuals -->
    <section class="panel">
      <h2>2. Visual Intuition</h2>
      <div class="visuals">
        <div class="canvas-card">
          <div class="canvas-title">
            <div><strong>Original Space</strong> <span>(we treat this as “high-D”)</span></div>
            <div class="legend"><span class="dot"></span>points · <span class="dot2"></span>neighbors/weights</div>
          </div>
          <canvas id="highCanvas" width="600" height="320"></canvas>
        </div>
        <div class="canvas-card">
          <div class="canvas-title">
            <div><strong>UMAP Embedding (2D)</strong></div>
            <div class="legend">
              <span class="dot"></span>embedded points
              <span class="dot2"></span>strong edges
            </div>
          </div>
          <canvas id="lowCanvas" width="600" height="320"></canvas>
        </div>
      </div>
    </section>
  </section>
</div>

<script>
/*
  UMAP INTERACTIVE EXPLAINER (simplified educational version)

  This demo captures the essential ideas:

  1) Build a local view of geometry with k-nearest neighbors.
  2) Turn those into a fuzzy weighted graph (strong edges = close neighbors).
  3) Find 2D coordinates whose fuzzy graph matches the original.

  NOTE: This is NOT a production-accurate UMAP implementation.
        It uses simplified formulas but matches the conceptual math.
*/

// ---------- Utilities ----------
function randUniform(a, b) {
  return a + Math.random() * (b - a);
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = (Math.random() * (i + 1)) | 0;
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function euclidean(p, q) {
  let s = 0;
  const d = p.coords.length;
  for (let i = 0; i < d; i++) {
    const diff = p.coords[i] - q.coords[i];
    s += diff * diff;
  }
  return Math.sqrt(s);
}

function scaleToCanvas(points, canvas, padding = 10) {
  if (!points.length) return [];
  const dim = points[0].coords.length >= 2 ? 2 : 1;
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const p of points) {
    const x = p.coords[0];
    const y = dim > 1 ? p.coords[1] : 0;
    if (x < minX) minX = x;
    if (x > maxX) maxX = x;
    if (y < minY) minY = y;
    if (y > maxY) maxY = y;
  }
  if (minX === maxX) { minX -= 1; maxX += 1; }
  if (minY === maxY) { minY -= 1; maxY += 1; }

  const w = canvas.width - 2 * padding;
  const h = canvas.height - 2 * padding;
  const sx = w / (maxX - minX);
  const sy = h / (maxY - minY);
  const s = Math.min(sx, sy);

  return points.map(p => {
    const x = padding + (p.coords[0] - minX) * s;
    const y = padding + (p.coords[1] - minY) * s;
    return { x, y };
  });
}

function scaleEmbeddingToCanvas(embedding, canvas, padding = 10) {
  if (!embedding.length) return [];
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (const p of embedding) {
    const x = p.x;
    const y = p.y;
    if (x < minX) minX = x;
    if (x > maxX) maxX = x;
    if (y < minY) minY = y;
    if (y > maxY) maxY = y;
  }
  if (minX === maxX) { minX -= 1; maxX += 1; }
  if (minY === maxY) { minY -= 1; maxY += 1; }

  const w = canvas.width - 2 * padding;
  const h = canvas.height - 2 * padding;
  const sx = w / (maxX - minX);
  const sy = h / (maxY - minY);
  const s = Math.min(sx, sy);

  return embedding.map(p => {
    const x = padding + (p.x - minX) * s;
    const y = padding + (p.y - minY) * s;
    return { x, y };
  });
}

// ---------- Dataset Generation ----------
function makeMoons(n) {
  const pts = [];
  const half = n / 2;
  for (let i = 0; i < n; i++) {
    if (i < half) {
      const t = Math.random() * Math.PI;
      const x = Math.cos(t);
      const y = Math.sin(t);
      pts.push({ coords: [x, y], label: 0, t });
    } else {
      const t = Math.random() * Math.PI;
      const x = 1 - Math.cos(t);
      const y = -0.3 - Math.sin(t);
      pts.push({ coords: [x, y], label: 1, t });
    }
  }
  return pts;
}

function makeBlobs(n) {
  const centers = [
    [-3, 0],
    [0, 3],
    [3, -2]
  ];
  const pts = [];
  for (let i = 0; i < n; i++) {
    const c = centers[i % centers.length];
    const x = c[0] + randUniform(-0.7, 0.7);
    const y = c[1] + randUniform(-0.7, 0.7);
    pts.push({ coords: [x, y], label: i % centers.length, t: i / n });
  }
  return pts;
}

function makeSwissRoll(n) {
  // Classic swiss roll: 3D, then we project it in the left canvas
  const pts = [];
  for (let i = 0; i < n; i++) {
    const t = randUniform(3.5, 12.5);
    const x = t * Math.cos(t);
    const z = t * Math.sin(t);
    const y = randUniform(-10, 10);
    pts.push({
      coords: [x, y, z],
      label: i / n,
      t: t
    });
  }
  return pts;
}

function generateData(kind, n) {
  if (kind === "moons") return makeMoons(n);
  if (kind === "blobs") return makeBlobs(n);
  return makeSwissRoll(n);
}

// ---------- Graph Construction (kNN + Fuzzy Weights) ----------
function buildKNNGraph(points, k) {
  const n = points.length;
  const neighbors = Array.from({ length: n }, () => []);
  const dists = Array.from({ length: n }, () => []);

  // Naive O(n^2) distances for clarity
  for (let i = 0; i < n; i++) {
    const row = [];
    for (let j = 0; j < n; j++) {
      if (i === j) continue;
      row.push({ j, d: euclidean(points[i], points[j]) });
    }
    row.sort((a, b) => a.d - b.d);
    const kRow = row.slice(0, Math.min(k, row.length));
    neighbors[i] = kRow.map(o => o.j);
    dists[i] = kRow.map(o => o.d);
  }

  // Smooth scale per point (simplified UMAP-style)
  // σ_i chosen so average neighbor weight is ~0.5
  const sigmas = new Array(n);
  const rhos = new Array(n);

  for (let i = 0; i < n; i++) {
    const di = dists[i];
    const rho = di.length ? di[0] : 0.0; // local connectivity
    rhos[i] = rho;

    if (!di.length) {
      sigmas[i] = 1.0;
      continue;
    }

    let lo = 1e-3, hi = 10.0;
    for (let it = 0; it < 25; it++) {
      const mid = 0.5 * (lo + hi);
      let sum = 0.0;
      for (let m = 0; m < di.length; m++) {
        const d = di[m];
        const v = d > rho ? Math.exp(-(d - rho) / mid) : 1.0;
        sum += v;
      }
      if (sum > di.length * 0.5) {
        hi = mid;
      } else {
        lo = mid;
      }
    }
    sigmas[i] = 0.5 * (lo + hi);
  }

  // Compute directed weights, then symmetrize:
  // w_ij = exp( -(max(d_ij - rho_i,0))/sigma_i )
  const directed = Array.from({ length: n }, () => ({}));
  for (let i = 0; i < n; i++) {
    const sigma = sigmas[i] || 1e-6;
    const rho = rhos[i];
    for (let idx = 0; idx < neighbors[i].length; idx++) {
      const j = neighbors[i][idx];
      const d = dists[i][idx];
      const num = d - rho;
      const val = d <= rho ? 1.0 : Math.exp(-num / sigma);
      directed[i][j] = val;
    }
  }

  const weights = Array.from({ length: n }, () => ({}));
  let maxW = 0.0;
  for (let i = 0; i < n; i++) {
    for (const key in directed[i]) {
      const j = parseInt(key);
      const w_ij = directed[i][j] || 0;
      const w_ji = directed[j]?.[i] || 0;
      // UMAP symmetrization:
      const w = w_ij + w_ji - w_ij * w_ji;
      if (w > 0) {
        weights[i][j] = w;
        if (w > maxW) maxW = w;
      }
    }
  }

  return { neighbors, weights, sigmas, rhos, maxW };
}

// ---------- Layout Optimization (Simplified UMAP-style) ----------
function initEmbedding(n) {
  const emb = [];
  for (let i = 0; i < n; i++) {
    emb.push({
      x: randUniform(-1, 1),
      y: randUniform(-1, 1)
    });
  }
  return emb;
}

function optimizeLayoutStep(embedding, weights, params) {
  const n = embedding.length;
  const lr = params.lr;
  const repulsion = params.repulsion;
  const a = 1.0;  // shape params for similarity ~ 1/(1 + a d^2)^b
  const b = 1.0;

  const forces = Array.from({ length: n }, () => ({ x: 0, y: 0 }));

  // Attractive forces on edges (encourage close neighbors)
  for (let i = 0; i < n; i++) {
    const row = weights[i];
    for (const key in row) {
      const j = parseInt(key);
      if (j <= i) continue; // handle edge once
      const w_hd = row[j];
      const pi = embedding[i];
      const pj = embedding[j];
      let dx = pi.x - pj.x;
      let dy = pi.y - pj.y;
      let dist2 = dx * dx + dy * dy + 1e-7;
      let dist = Math.sqrt(dist2);

      // Low-D similarity (simplified)
      const w_ld = 1.0 / (1.0 + a * Math.pow(dist2, b));

      // Cross-entropy-ish gradient: (w_ld - w_hd)
      const gradCoeff = (w_ld - w_hd);

      const fx = gradCoeff * (dx / (dist + 1e-7));
      const fy = gradCoeff * (dy / (dist + 1e-7));

      forces[i].x += fx;
      forces[i].y += fy;
      forces[j].x -= fx;
      forces[j].y -= fy;
    }
  }

  // Repulsive forces between random pairs
  const samples = Math.min(5 * n, n * n);
  for (let s = 0; s < samples; s++) {
    const i = (Math.random() * n) | 0;
    const j = (Math.random() * n) | 0;
    if (i === j) continue;
    const pi = embedding[i];
    const pj = embedding[j];
    let dx = pi.x - pj.x;
    let dy = pi.y - pj.y;
    let dist2 = dx * dx + dy * dy + 1e-7;
    if (dist2 === 0) {
      dx = (Math.random() - 0.5) * 1e-3;
      dy = (Math.random() - 0.5) * 1e-3;
      dist2 = dx * dx + dy * dy;
    }
    const inv = 1.0 / dist2;
    const f = repulsion * inv;
    forces[i].x += f * dx;
    forces[i].y += f * dy;
    forces[j].x -= f * dx;
    forces[j].y -= f * dy;
  }

  // Apply forces
  for (let i = 0; i < n; i++) {
    embedding[i].x -= lr * forces[i].x;
    embedding[i].y -= lr * forces[i].y;
  }
}

// ---------- Rendering ----------
const highCanvas = document.getElementById("highCanvas");
const lowCanvas = document.getElementById("lowCanvas");
const hctx = highCanvas.getContext("2d");
const lctx = lowCanvas.getContext("2d");

function clearCanvas(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
}

function drawHigh(points, knn, weights, step) {
  clearCanvas(hctx);
  if (!points.length) return;
  const projected = scaleToCanvas(points, highCanvas, 14);

  // Step >= 2: draw neighbor edges
  if (step >= 2 && knn) {
    hctx.lineWidth = 0.4;
    for (let i = 0; i < points.length; i++) {
      const pi = projected[i];
      const row = step >= 3 ? weights[i] : null;
      const neigh = knn[i] || [];
      for (let idx = 0; idx < neigh.length; idx++) {
        const j = neigh[idx];
        const pj = projected[j];
        let alpha = 0.16;
        if (step >= 3 && row && row[j] != null) {
          alpha = 0.08 + 0.5 * row[j]; // darker = higher membership
        }
        hctx.strokeStyle = `rgba(56,189,248,${alpha})`;
        hctx.beginPath();
        hctx.moveTo(pi.x, pi.y);
        hctx.lineTo(pj.x, pj.y);
        hctx.stroke();
      }
    }
  }

  // Draw points
  for (let i = 0; i < points.length; i++) {
    const p = projected[i];
    const label = points[i].label || 0;
    const base = labelToColor(label);
    hctx.fillStyle = base;
    hctx.beginPath();
    hctx.arc(p.x, p.y, 2.2, 0, Math.PI * 2);
    hctx.fill();
  }
}

function drawLow(embedding, weights, step) {
  clearCanvas(lctx);
  if (!embedding.length) return;

  const projected = scaleEmbeddingToCanvas(embedding, lowCanvas, 14);

  // Edges for context when step >= 4
  if (step >= 4 && weights) {
    lctx.lineWidth = 0.35;
    for (let i = 0; i < embedding.length; i++) {
      const row = weights[i];
      for (const key in row) {
        const j = parseInt(key);
        if (j <= i) continue;
        const w = row[j];
        const alpha = 0.03 + 0.35 * w;
        lctx.strokeStyle = `rgba(56,189,248,${alpha})`;
        lctx.beginPath();
        lctx.moveTo(projected[i].x, projected[i].y);
        lctx.lineTo(projected[j].x, projected[j].y);
        lctx.stroke();
      }
    }
  }

  // Draw embedded points
  for (let i = 0; i < embedding.length; i++) {
    const p = projected[i];
    lctx.fillStyle = "rgba(34,197,94,0.96)";
    lctx.beginPath();
    lctx.arc(p.x, p.y, 2.2, 0, Math.PI * 2);
    lctx.fill();
  }
}

// Simple label → color
function labelToColor(label) {
  const palette = [
    "rgba(34,197,94,0.96)",
    "rgba(56,189,248,0.96)",
    "rgba(251,191,36,0.96)",
    "rgba(248,113,113,0.96)"
  ];
  return palette[label % palette.length];
}

// ---------- Explanation Text ----------
const mathBlock = document.getElementById("mathBlock");
const explainText = document.getElementById("explainText");
const statusText = document.getElementById("statusText");

function setStepLabels(activeStep) {
  document
    .querySelectorAll("[data-step-label]")
    .forEach(el => {
      const s = parseInt(el.getAttribute("data-step-label"), 10);
      if (s === activeStep) {
        el.classList.add("active");
      } else {
        el.classList.remove("active");
      }
    });
}

function updateExplanation(step, state) {
  setStepLabels(step);
  const k = state.k;
  if (step === 1) {
    mathBlock.textContent =
`We start with points xᵢ in a high-dimensional space ℝᵈ.

UMAP's goal:
  find low-dimensional yᵢ in ℝ²
  such that neighborhood relationships are preserved.`;
    explainText.innerHTML =
`<span class="explain-highlight">Step 1 — Geometry.</span><br/>
Pick a dataset that has interesting shape: moons (nonlinear), blobs (clusters), or a 3D swiss roll.
These represent your original feature space.<br/><br/>
UMAP assumes:
<ul>
<li>Your data lies on a lower-dimensional <b>manifold</b> inside a higher-dimensional space.</li>
<li>Local distances are meaningful; global structure is built from stitching locals together.</li>
</ul>
Use the left plot to see that raw geometry. Next: we turn this intuition into a graph.`;
  } else if (step === 2) {
    mathBlock.textContent =
`For each point i:
  • compute distances d(i, j)
  • pick its k nearest neighbors N_k(i)

This encodes local structure as a directed graph.`;
    explainText.innerHTML =
`<span class="explain-highlight">Step 2 — k-Nearest Neighbors.</span><br/>
For each point xᵢ we find the ${k} closest other points.
This builds a directed graph:
edges point from i to its local neighbors.<br/><br/>
What this means:
<ul>
<li>You no longer care about all pairwise distances; only the strongest local ones.</li>
<li>This graph is UMAP's belief about "who is near whom" in the original space.</li>
</ul>
On the left, edges show each point linked to its neighbors. Notice how structure already appears.`;
  } else if (step === 3) {
    mathBlock.textContent =
`UMAP turns distances into fuzzy edge weights.

For neighbor j of i:
  ρᵢ = distance to i's closest neighbor
  σᵢ = scale so neighbor weights sum nicely

  wᵢⱼ = exp( -max(0, d(i,j) - ρᵢ) / σᵢ )

Symmetrize:
  wᵢⱼ(sym) = wᵢⱼ + wⱼᵢ - wᵢⱼ wⱼᵢ`;
    explainText.innerHTML =
`<span class="explain-highlight">Step 3 — Fuzzy Graph.</span><br/>
Instead of saying "neighbor or not", UMAP says
"how strongly should i and j be connected?" via weights wᵢⱼ ∈ (0,1].<br/><br/>
Key ideas:
<ul>
<li>ρᵢ (rho) handles very close points so they don't dominate.</li>
<li>σᵢ (sigma) adapts to local density: crowded regions get smaller sigmas.</li>
<li>Symmetrization produces an undirected fuzzy graph that reflects mutual affinity.</li>
</ul>
On the left, thicker/brighter edges mean higher membership strength in the same local fuzzy set.`;
  } else if (step === 4) {
    mathBlock.textContent =
`We want low-D points yᵢ whose fuzzy graph matches.

Define low-D similarity (here simplified):
  qᵢⱼ = 1 / (1 + a ||yᵢ - yⱼ||²)ᵇ

UMAP minimizes (simplified cross-entropy):
  L ≈ Σ [ wᵢⱼ log(wᵢⱼ / qᵢⱼ) + (1-wᵢⱼ) log((1-wᵢⱼ)/(1-qᵢⱼ)) ]

We move yᵢ by gradient descent on L.`;
    explainText.innerHTML =
`<span class="explain-highlight">Step 4 — Layout Optimization.</span><br/>
Now we find 2D points yᵢ that preserve the fuzzy graph:
<ul>
<li>If wᵢⱼ is large in high-D, we pull yᵢ and yⱼ together (attractive force).</li>
<li>If wᵢⱼ is small, we gently push them apart (repulsive force).</li>
</ul>
The exact UMAP implementation uses a carefully derived cross-entropy loss and negative sampling.
This demo runs a simplified version:
it uses forces based on (qᵢⱼ - wᵢⱼ) to nudge points until the 2D fuzzy graph resembles the original.<br/><br/>
Hit <b>“Run layout”</b> to watch structure emerge on the right.`;
  }
}

// ---------- Main State & Wiring ----------
const datasetSelect = document.getElementById("datasetSelect");
const numPointsInput = document.getElementById("numPoints");
const kNeighborsInput = document.getElementById("kNeighbors");
const stepSlider = document.getElementById("stepSlider");
const regenBtn = document.getElementById("regenBtn");
const rebuildBtn = document.getElementById("rebuildBtn");
const resetLayoutBtn = document.getElementById("resetLayoutBtn");
const playBtn = document.getElementById("playBtn");
const kLabel = document.getElementById("kLabel");

let points = [];
let knn = null;
let weights = null;
let embedding = [];
let animating = false;
let currentStep = 1;

function updateKLabel() {
  const k = parseInt(kNeighborsInput.value, 10);
  kLabel.textContent = `k = ${k} neighbors per point`;
}

function regenerate() {
  const kind = datasetSelect.value;
  let n = parseInt(numPointsInput.value, 10);
  if (!Number.isFinite(n) || n < 40) n = 40;
  if (n > 800) n = 800;
  numPointsInput.value = n;
  points = generateData(kind, n);
  knn = null;
  weights = null;
  embedding = initEmbedding(points.length);
  statusText.textContent = `Generated ${n} points (${kind}).`;
  redraw();
}

function rebuildGraph() {
  if (!points.length) return;
  const k = parseInt(kNeighborsInput.value, 10);
  const g = buildKNNGraph(points, k);
  knn = g.neighbors;
  weights = g.weights;
  statusText.textContent = `Built kNN graph & fuzzy weights (k = ${k}).`;
  redraw();
}

function resetLayout() {
  if (!points.length) return;
  embedding = initEmbedding(points.length);
  statusText.textContent = "Layout reset (random initialization).";
  redraw();
}

function redraw() {
  updateExplanation(currentStep, { k: parseInt(kNeighborsInput.value, 10) });
  drawHigh(points, knn, weights, currentStep);
  drawLow(embedding, weights, currentStep);
}

function stepUMAPAnimation() {
  if (!animating) return;
  if (!embedding.length || !weights) {
    animating = false;
    playBtn.textContent = "▶ Run layout";
    return;
  }
  // several optimization steps per frame for visible movement
  for (let i = 0; i < 8; i++) {
    optimizeLayoutStep(embedding, weights, {
      lr: 0.015,
      repulsion: 0.0007
    });
  }
  drawLow(embedding, weights, 4);
  requestAnimationFrame(stepUMAPAnimation);
}

// Event listeners
datasetSelect.addEventListener("change", () => {
  regenerate();
});

numPointsInput.addEventListener("change", () => {
  regenerate();
});

kNeighborsInput.addEventListener("input", () => {
  updateKLabel();
});

regenBtn.addEventListener("click", () => {
  regenerate();
});

rebuildBtn.addEventListener("click", () => {
  rebuildGraph();
  if (currentStep < 2) {
    currentStep = 2;
    stepSlider.value = 2;
  }
  redraw();
});

resetLayoutBtn.addEventListener("click", () => {
  resetLayout();
});

playBtn.addEventListener("click", () => {
  if (!weights) {
    statusText.textContent = "Build the graph first (click 'Build graph').";
    return;
  }
  if (!animating) {
    animating = true;
    currentStep = 4;
    stepSlider.value = 4;
    playBtn.textContent = "⏸ Pause";
    statusText.textContent = "Optimizing layout (simplified UMAP forces)...";
    updateExplanation(4, { k: parseInt(kNeighborsInput.value, 10) });
    stepUMAPAnimation();
  } else {
    animating = false;
    playBtn.textContent = "▶ Run layout";
    statusText.textContent = "Layout paused.";
  }
});

stepSlider.addEventListener("input", () => {
  const v = parseInt(stepSlider.value, 10);
  currentStep = v;
  if (v !== 4 && animating) {
    animating = false;
    playBtn.textContent = "▶ Run layout";
  }
  redraw();
});

// Initialize labels + first run
updateKLabel();
regenerate();
updateExplanation(1, { k: parseInt(kNeighborsInput.value, 10) });
drawHigh(points, knn, weights, 1);
drawLow(embedding, weights, 1);
</script>
</body>
</html>
